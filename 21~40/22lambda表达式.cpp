#include <iostream>

using namespace std;
//匿名的函数 简洁 不需要额外写一个命名函数
/*lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

    [] - 不捕捉任何变量
    [&] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)
    [=] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)
        拷贝的副本在匿名函数体内部是只读的
    [=, &foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo(只有foo引用)
    [bar] - 按值捕获 bar 变量，同时不捕获其他变量(指定变量)
    [&bar] - 按引用捕获 bar 变量，同时不捕获其他变量
    [this] - 捕获当前类中的 this 指针
        让 lambda 表达式拥有和当前类成员函数同样的访问权限
        如果已经使用了 & 或者 =, 默认添加此选项

。*/
//使用格式 [capture](params) opt -> ret  {body;}; 返回值后置
//           类型     参数   选项   返回值ret     函数体
//                        (一般为空)    (一般情况不要写编译器会自动推导)  

//如果()没有参数可以省略掉()  []{return 1;}写法
/*
opt 选项， 不需要可以省略

    mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
    exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();

返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。

函数体：函数的实现，这部分不能省略，但函数体可以为空。 

*/

void func(int x,int y)
{
    int a; //该成static []不定义也能捕捉
    int b;
    [=,&b]() ->int {  //中阔号为空表示不捕捉任意的外部变量 下面赋值的a和b不能实现
        int c =a;
        int d =b;
        return 0;
    };
}
int main(void)
{
    
    return 0;
}